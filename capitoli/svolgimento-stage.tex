% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Resoconto dello stage}
\label{cap:resoconto-stage}
%**************************************************************

%**************************************************************
\section{Pianificazione}
Prima dell'inizio del progetto di stage, insieme al mio tutor aziendale, abbiamo stilato le attività principali che avrei dovuto svolgere durante il periodo a disposizione. Queste attività sono riportate nella \hyperref[tab:pian]{tabella 2.1}.\\
Il mio tutor ha deciso che, successivamente all'attività di analisi, avrei dovuto svolgere un colloquio con lui per decidere insieme le tecnologie più promettenti e valide nel contesto di anti frode.\\
Durante i primi giorni di stage abbiamo anche svolto vari colloqui per pianificare in dettaglio le varie attività, le modalità di scelta in base al loro ambito di sviluppo e le tecnologie consigliate.

\section{Analisi}
\subsection{Introduzione}
Nei primi giorni di stage io ed il mio tutor abbiamo deciso i principali punti su cui analizzare le varie tecnologie. Questi sono conseguenti all'ambito di sviluppo dell'azienda e le tecnologie che già adottano.\\
i punti di interesse solo:
\begin{itemize}
\item{\textbf{Licenza:}} verificare che tipo di licenza ha il prodotto, se ha una versione gratuita e che tipo limitazioni ha rispetto a quella a pagamento.
\item{\textbf{Tipo:}} verificare il tipo di tecnologia implementata, se una base di dati a grafo nativa\glsfirstoccur o non nativa\glsfirstoccur.
\item{\textbf{Modelli disponibili:}} verificare che tipi di modelli\glsfirstoccur offre.
\item{\textbf{Community:}} verificare l'ampiezza della \textit{community} del prodotto in analisi, avendola molto sviluppata é possibile ricercare consigli o risoluzioni di determinati problemi nei vari \textit{forum} di riferimento.
\item{\textbf{Tecnologie sopportate nativamente(di rilievo per l'azienda):}} verificare se la tecnologia mette a disposizione un supporto a tecnologie di riferimento all'azienda quali Java o Spring.
\item{\textbf{Linguaggio di interrogazione proprietario:}} verificare se la tecnologia in analisi mette a disposizione un linguaggio di interrogazione proprietario e ottimizzato per essa, analizzando la sua espressivitá.
\item{\textbf{Supporto Tinkerpop\footnote{Tinkerpop: url= \link{http://tinkerpop.apache.org/}}:}} verificare se la tecnologia mette a disposizione il supporto ad Apache Tinkerpop, sfruttando quindi un interfaccia comune, permettendo poi il passaggio ad un altra tecnologia che lo supporti a costi nulli.
\item{\textbf{Clustering\glsfirstoccur:}} verificare se la tecnologia mette a disposizione un sistema di \textit{clustering} pronto all'uso, il tipo e se ha la possibilitá di eseguire \textit{query} distribuite. Infine verificare se questa é disponibile nelle versione gratuita.
\item{\textbf{Security:}} verificare che sistemi di sicurezza dei dati la tecnologia mette a disposizione e se esiste la possibilità di dividere il \textit{database} in zone facendole diventare accessibili solo a determinati utenti.\\

\end{itemize}
\textbf{Le informazioni necessarie all'analisi le ho reperite in primo luogo dalle documentazioni ufficiali delle case produttrici e successivamente dai \textit{forum} quali StackOverflow\footnote{StackOverflow: url= \link{https://stackoverflow.com/}} e Dzone\footnote{Dzone: url= \link{https://dzone.com/}}}
\subsection{Tecnologie in analisi}
Le tecnologie le ho scelte in base a quelle più diffuse o più promettenti sulla carta attraverso ricerche su internet.
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.35]{immagini/graphdb.png}

	\caption{\textit{Alternative tecnologiche nel mercato \link{https://goo.gl/d3UUgT}}}
\end{figure}

\subsubsection{Sparksee(DEX)}
Sparksee\footnote{Sparksee: url= \link{http://www.sparsity-technologies.com/}} è un grafo nativo sviluppato in C++ da Spark Technologies a fine 2008 sotto nome \textbf{DEX}. Successivamente nel 2014 cambia nome in \textbf{Sparksee}.\\
E' stato il primo \textit{database} a grafo disponibile per Android e iOS.\\
Supporta tecnologie di rilievo per l'azienda come Java, Maven e viene rilasciato per Linux, MacOs, Windows e per i principali sistemi operativi mobili.
La casa produttrice dichiara come caso d'uso possibile il rilevamento di frode bancarie.\\
Questa tecnologia viene rilasciata solamente in versione con licenza commerciale ed accademica con il limite ad un milione di nodi.

\subsubsection{Neo4j}
Neo4j\footnote{Neo4j: url= \link{https://neo4j.com/}} è la base di dati a grafo nativa più diffusa al mondo, e, anche grazie a questo, ha una \textit{community} molto ampia. E' un \textit{software} sviluppato in Java da Neo Technology nel 2007. E' adottato da multinazionali come Microsoft, AirBnb, IBM, Ebay.\\
Neo4j ha un linguaggio di interrogazione proprietario, chimato \textbf{Chyper}, molto espressivo e ottimizzato. Supporta le tecnologie di rilievo per l'azienda, compreso Spring Data\footnote{Spring data: url= \link{http://projects.spring.io/spring-data/}}. Neo4j viene rilasciato in versione \textit{community} gratuita con nessuna limitazione di ampiezza della base di dati senza la possibilità di eseguirlo in modo distibuito, al contrario di quella \textit{Enterprise} a pagamento.

\subsubsection{ArangoDB}
ArangoDB\footnote{ArangoDB: url= \link{https://www.arangodb.com/}} è un \textit{database} multi modello sviluppato in C++ nato nel 2011. E' un \textit{database} principalmente documentale ma con collezzioni che, raccogliendo la chiave di entrata e di uscita, simulano il funzionamento a grafo. Questo permette di organizzare i dati utilizzando il modello a grafo, documentale e chiave/valore.\\
Gli sviluppatori promettono la \textbf{flessibilità} data dalle base di dati multi modello e \textbf{velocità} paragonabile ai \textit{database} a grafo nativi.\\
ArangoDB ha un linguaggio di interrogazione proprietario simile ad SQL\glsfirstoccur e viene rilasciato in versione gratuita con limitazioni solo nell'ambito della sicurezza.
\subsubsection{AllegroGraph}
AllegroGraph\footnote{AllegroGraph: url= \link{https://franz.com/agraph/allegrograph/}} è un software per \textit{database} a grafo nativo sviluppato insieme agli \textit{standard} W3C\footnote{W3C: url= \link{https://www.w3.org/}} per il \textit{web} semantico\glsfirstoccur  nel 2004. Supporta tecnologie di interesse all'azienda ma non ha un linguaggio di interrogazione proprietario. Viene rilasciato solo con licenza commerciale a pagamento.
\subsubsection{OrientDB}
OrientDB\footnote{OrientDB: url= \link{http://orientdb.com/orientdb/}} è un \textit{software} per base di dati multi modello sviluppato in Java da uno sviluppatore italiano chiamato Luca Garulli\footnote{Luca Garulli: url= \link{https://www.linkedin.com/in/garulli}}. E' un \textit{database} principalmente documentale ma, salvando attraverso tabelle gli indici fisici di inizio e fine dell'arco, riesce ad implementare anche il modello a grafo nativo. \\
Per scelta puramente commerciale hanno deciso di integrare un linguaggio di interrogazione molto simile a SQL, limitando di molto l'espressività nelle ricerche nel modello a grafo. Viene rilasciato in versione sia a pagamento che \textit{community} con nessuna limitazione di rilievo.
\subsubsection{Titan}
Titan\footnote{Titan: url= \link{http://titan.thinkaurelius.com/}} è un software in grado di sfruttare \textit{storage backend} come Apache Cassandra\footnote{Apache Cassandra: url= \link{http://cassandra.apache.org/}} per l'immagazzinamento dei dati. E' capace di astrarre i dati nello \textit{storage} ed organizzarli come se fossero a grafo, di conseguenza non utilizza una base di dati a grafo nativa.
Questa possibilità di scelta dello \textit{storage backend} lo rende molto valido se l'azienda utilizzasse una tecnologia che lo supporta, questo porterebbe ad un costo di passaggio tecnologico più contenuto.\\
Titan non offre un linguaggio di interrogazione proprietario ma supporta pienamento Tinkerpop.  Viene rilasciato in licenza Apache 2\footnote{Apache 2: url= \link{https://www.apache.org/licenses/LICENSE-2.0}}.
\subsection{Scelta tecnologica}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.45]{immagini/neo4j.png}
	\includegraphics[scale=0.3]{immagini/orientdb.png}
	\caption{\textit{Logo \href{https://neo4j.com/}{Neo4j} e \href{http://orientdb.com/orientdb/}{OrientDB}}}
\end{figure}
Dopo un colloquio dove ho mostrato al mio tutor i risultati dell'analisi, in comune accordo abbiamo scelto le due tecnologie più promettenti ed interessanti.\\
Abbiamo scelto \textbf{Neo4j} per il suo linguaggio di interrogazione molto espressivo e la sua diffusione a livello mondiale che porta ad una \textit{community} molto attiva.\\
Infine abbiamo scelto anche \textbf{OrientDB} essendo il \textit{database} multi modello più promettente sulla carta che organizza i dati come uno a grafo nativo.
\\
\\

\section{Sviluppo del prototipo}
\subsection{Base di dati}
In base al problema descritto nella \hyperref[sec:prob]{sezione 2.1.1} e dinamiche di Smash\textregistered\ ho organizzato i dati, per tutti e due i \textit{database}, nel seguente modo:
\begin{itemize}
\item{\textbf{Nodi:}}
\begin{itemize}
\item{\textbf{EntityId:}} è il nodo che rappresenta un utente di una banca, esso può sia svolgere \textbf{transazioni} verso un \textit{AccountId} che avere \textbf{relazioni di appartenenza} verso uno, o più, \textit{AccountId}.
\item{\textbf{AccountId:}} è il nodo che rappresenta una coordinata bancaria ad esempio un iban, esso può avere transazioni verso altri \textit{AccountId} ed avere massimo una relazione di appartenenza da un \textit{EntityId} a questo nodo.
\end{itemize}
\item{\textbf{Archi:}}
\begin{itemize}
\item{\textbf{TRANSACTION:}} è l'arco che rappresenta una transazione, questo può provenire da un \textit{AccountId} o \textit{EntityId} verso un \textit{AccountId}. Questo ha diverse proprietà tra cui di obbligatorie la data di avvenuta transazione, l'importo e la valuta, e di non obbligatorie come la città e il paese dove è stata eseguita la transazione.
\item{\textbf{OWN:}} è l'arco che descrive la relazione di appartenenza da un \textit{EntityId} ad un \textit{AccountId}. Un \textit{EntityId} può avere un numero a piacere di relazioni di appartenenza, al contrario un \textit{AccountId} può avere al massimo un arco entrante di tipo \textit{OWN}.
\end{itemize}
\end{itemize}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.4]{immagini/graph.jpg}
	\caption{\textit{Schema della base di dati}}
\end{figure}
\textbf{A causa dei problemi legati alle politiche della protezione dei dati sensibili, non ho potuto utilizzare dati reali per il popolamento dei \textit{database} ma ho dovuto creare un progetto per la generarmeli in modo casuale.}

\subsection{Prototipo}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.4]{immagini/packages.png}
	\caption{\textit{Diagramma dei package del prototipo}}
\end{figure}
Ho deciso di dividere il prototipo in più progetti sotto l'unico aggregato Maven\glsfirstoccur\ chiamato \textit{xtn\textunderscore research\textunderscore graphdbs}. Questa tecnica l'ho utilizzata per gestire tutte le versioni delle dipendenze in un unico file di configurazione, e, sopratutto, per avere la comodità di eseguire la \textit{build} di tutti i progetti in un unico comando, lasciando a Maven l'onere di risolvere tutte le dipendenze.\\


\subsubsection{basegraphdb}
\textit{Basegraphdb} é il progetto che contiene le varie interfacce comuni tra cui \textit{ReputationController}. Questa é l'interfaccia comune per gestire la reputazione delle varie entitá presenti nei vari \textit{database}. Ogni implementazione, quindi sia \textit{graphdb-neo4j} che \textit{graphdb-orientDb}, conterrà una classe che la implementerà.
\subsubsection{graphdb-orientdb}
\textit{Graphdb-orientDb} é il progetto per la gestione della reputazione tramite OrientDB, esso ha all'interno una classe chiamata \textit{ReputationControllerOrientDb} che implementa \textit{ReputationController}. Questa implementazione usa Tinkerpop\footnote{Tinkerpop: url=\link{http://tinkerpop.apache.org/}} per interfacciarsi con il \textit{database}.
\subsubsection{graphdb-neo4j}
\textit{Graphdb-neo4j} è il progetto per la gestione della reputazione tramite Neo4j, esso ha all'interno una classe chiamata \textit{ReputationControllerNeo4j} che implementa \textit{ReputationController}. Questa implementazione utilizza \textit{Spring Data Neo4j} per interfacciarsi ed eseguire il \textit{map} degli oggetti Java nel \textit{database}.


\subsubsection{graphdb-csv}
\textit{Graphdb-csv} è il progetto per creare tutti i documenti in formato CSV contenenti le entità per popolare i diversi tipi di \textit{database}. \textbf{Questo crea dati in modo casuale nei migliori dei casi, cioè ogni \textit{AccountId} ha il proprio \textit{EntityId}.}\\

\subsubsection{graphdb-insert}
\textit{Graphdb-insert} inserisce in modo del tutto causale un certo numero, definito dall'utente, di \textit{EntityId, AccountId, Transaction} utilizzando l'interfaccia comune \textit{ReputationController}.\\
\textbf{Questo progetto deve essere usato solo per inserire un modesto numero di nodi ed archi} visto che l'aggiunta di ogni \textit{record} ci impiega 500 millisecondi. In caso contrario è consigliato generarsi i CSV delle entità utilizzando il progetto \textit{graphdb-csv} e successivamente importarli nel \textit{database} scelto.
\subsubsection{graphdb-poc}
\textit{Graphdb-poc} è il progetto che si occupa solamente di istanziare le varie implementazioni di \textit{ReputationController} ed eseguire i vari metodi d'interfaccia tracciando, e stampando a video, il nome del metodo, il risultato ottenuto ed il tempo impiegato.\\
Questo progetto non ha dipendenze verso le varie implementazioni ma solamente verso l'interfaccia. Questo è possibile delegando a Spring l'onere di iniettare tutte le classi che implementano l'interfaccia comune. \textbf{In questo modo si ha un disaccoppiamento tra questo progetto e le varie implementazioni e, sopratutto, se in futuro ci fosse il bisogno di aggiungerne un altra non sarebbe necessario modificare il codice di questo progetto.}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.75]{immagini/poc.png}
	\caption{\textit{Risultati stampati da graphdb-poc}}
\end{figure}
\section{Utilizzo della libreria}
Sfruttanto la \textit{dependency injection} \footnote{dependency injection: url= \link{https://en.wikipedia.org/wiki/Dependency\textunderscore injection}} di Spring, per utilizzare la libreria del calcolo della reputazione è sufficiente creare una classe simile alla seguente.
\begin{lstlisting}
package it.ldario;

import it.ldario.graphdbneo4j.ReputationControllerNeo4j;
//import it.ldario.graphdborientDb.ReputationControllerOrientDb;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MiaClasse implements CommandLineRunner {

    public static void main(String[] args) {
        SpringApplication.run(MiaClasse.class, args);
    }
    
    
	
	//utilizzando, come tipo statico, ReputationControllerNeo4j oppure //ReputationControllerOrientDb verra' usato, rispettivamente //l'implementazione di Neo4j o OrientDB
    private ReputationControllerNeo4j reputationController;
    //private ReputationControllerOrientDb reputationController;



    @Autowired
    public MiaClasse(ReputationControllerNeo4j reputationController) {
        this.reputationController = reputationController;
    }
    

    @Override
    public void run(String... strings) throws Exception {
        //aggiunge al database scelto(orientDB oppure Neo4j), dipende dal tipo //che viene dichiarato, un entity con id="Luca"
        reputationController.addAccountId("Luca");

        //stampa la reputazione totale dell'entity "Luca"
        System.out.println(reputationController.getTotalReputation("Luca"));
        
        

        //stampa il totale delle transazioni effettuate da Luca negli ultimi //15 giorni
		System.out.println(reputationController
        						.getAmountAccountIdInATimeRange("Luca", 15));
        						
        						
        						
        //aggiunge al database scelto(orientDB oppure Neo4j), dipende dal tipo //che viene dichiarato, un account con id "IT123"
        
         TransactionBuilder transactionBuilder = new TransactionBuilder(); 
        transactionBuilder.setCountry("Italy").setCity("San Michele delle Badesse").setAmount(100).setCurrency("Euro");
        reputationController.addTransaction("Luca","IT123",transactionBuilder
        																.build());
        

    }
}
\end{lstlisting}



\section{Verifica e validazione}
\subsection{Verifica}
Nell'attività di verifica ho utilizzato JUnit\footnote{JUnit: url= \link{http://junit.org/junit5/}} e Mockito\footnote{Mockito: url= \link{http://site.mockito.org/}} per facilitare la creazione dei \textit{test}.\\
Sono state testate tutte le \textit{query} utilizzando un immagine docker\footnote{Docker: url= \link{https://www.docker.com/}} di \textit{test}, escluse quelle banali auto generate da Spring.
Invece per testare le varie unità mi sono aiutato istanziando ed istruendo facilmente dei \textit{mock} utilizzando Mockito.
In accordo con il mio tutor aziendale è stata decisa la soglia minima di copertura dei test del 85\%.\\
La copertura finale dei test si è attestata sul 88\% tra il codice consegnato in azienda.
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.4]{immagini/test.jpg}
	\caption{\textit{Esempio di test utilizzando Mockito e JUnit}}
\end{figure}
\\
Ogni test ha uno ed uno solo confronto al suo interno ed ha un nome che indica con precisione che operazioni andrà ad eseguire. Questo ha il vantaggio di sapere esattamente con che condizioni il \textit{test} fallisce solamente leggendo il nome.
\subsection{Validazione}
Tutto il materiale consegnato, quindi sia codice che documentazione, è stato revisionato e validato dal mio tutor interno, Giuseppe Pavan.

\newpage
\section{Conclusioni}
\subsection{Vantaggi e svantaggi di una base di dato a grafo}
Durante la mia analisi mi sono scontrato con i seguenti vantaggi e svantaggi nel utilizzare una base di dati a grafo.
\subsubsection{Vantaggi}
\begin{itemize}
\item{\textbf{Velocità:}} se il caso d'uso è adatto e si organizza i dati in modo intelligente si riesce a ridurre la maggior parte delle \textit{query} ad operazioni banali, sfruttando la natura dei grafi. Nell'ambito anti frode molte operazioni si riducono al "\textit{conta quante volte la persona \textbf{A} ha fatto una determinata cosa, chiamata \textbf{Z}, verso un entità \textbf{B}}" dove A e B sono nodi e Z è l'arco che li collega.
\item{\textbf{Espressività della ricerca:}} se il caso d'uso che si va a modellare è adatto alla natura dei grafi, l'espressività della ricerca è tale che le \textit{query} risultano, molte volte, banali anche dal punto di vista della scrittura.
\item{\textbf{Tutto è collegato:}} data dalla natura dei grafi, si ha un enorme possibilità di creare ricerche che esplorano in profondità il grafo date determinate condizioni. Nell'ambito anti frode succede molto spesso di eseguire delle ricerche che sfruttano questa caratteristica.
\end{itemize}
\subsubsection{Svantaggi}
\begin{itemize}
\item{\textbf{Casi d'uso limitati:}} solo pochi \textit{use case} sono adatti ad essere modellati come un grafo, quindi è molto rischioso modellare totalmente la propria base di dati utilizzando questa tecnologia. Questo perchè in futuro potrebbe esserci la necessità di aggiungere dati al modello non adatti a questo tipo di \textit{database}. Questo limita il normale ciclo di vita di un \textit{software}.
\item{\textbf{Tecnologia di nicchia:}} essendo una tecnologia di nicchia la possibilità di informarsi, tramite community, è ridotta rispetto ad altre tecnologie piu diffuse, come possono essere i \textit{database} relazionali.
\end{itemize}
\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.33]{immagini/fraud.png}
	\caption{\textit{Esempio di un caso d'uso orientato all'anti frode \link{http://archive.is/LpXtZ}}}
\end{figure}


\subsection{PRO e CONTRO Neo4j rispetto OrientDB}
\subsubsection{PRO}
\begin{itemize}
\item{\textbf{Espressività:}} chyper, il linguaggio di interrogazione di Neo4j, inizialmente può spaventare, essendo diverso da quelli che siamo abituati a vedere. Dopo un breve periodo di apprendimento risulta, però, facile da utilizzare e molto potente nelle ricerche. Questo è dato dalla sintassi molto regolare ed espressiva con pochissime nozioni.
\item{\textbf{Spring Data Neo4j:}} libreria ben fatta e documentata per astrarre l'interazione con la base di dati, al contrario di OrientDB.
\item{\textbf{Importatore da CSV:}} popolamento della base di dati tramite documento CSV nettamente più veloce rispetto ad OrientDB.
\end{itemize}
\subsubsection{CONTRO}
\begin{itemize}
\item{\textbf{Input/Output lento:}} le librerie di Neo4j, quali Spring Data ed in generale i \textit{driver} java, risultano più lenti rispetto ad quelli di OrientDB. Questo l'ho notato calcolando la differenza tra la velocità netta delle \textit{query}, eseguendola nella \textit{dashboard}, con quella tramite i \textit{driver} e successivamente confrontandola con OrientDB.
\end{itemize}
\subsection{PRO e CONTRO OrientDB rispetto Neo4j}
\subsubsection{PRO}
\begin{itemize}
\item{\textbf{Velocità:}} pur essendo un \textit{database} multi modello la velocità nelle ricerche è comparabile ad una base di dati a grafo.
\end{itemize}
\subsubsection{CONTRO}
\begin{itemize}
\item{\textbf{Spring Data OrientDB:}} non documentato ed acerbo. Questo mi ha portato ad usare Tinkerpop\footnote{Tinkerpop: url= \link{http://tinkerpop.apache.org/}} portando allo sviluppo di un software meno organizzato rispetto a quello di Neo4j.
\item{\textbf{Espressività:}} l'azienda produttrice di OrientDB ha fatto la scelta, per me puramente commeRciale, di utilizzare un linguaggio simile ad SQL\footnote{SQL: url= \link{https://it.wikipedia.org/wiki/Structured\textunderscore Query\textunderscore Language}} per l'interrogazione della base di dati. Questo diminuisce sostanzialmente l'espressività delle \textit{query}, rendendo complicato lo sviluppo di operazioni con svariate transazioni su archi.
\item{\textbf{Spazio su disco:}} per rendere un database multi modello nativo gli sviluppatori di OrientDB hanno dovuto replicare molti dati, aumentando di circa 0.4 volte lo spazio necessario per immagazzinare i dati (prova eseguita con 30 milioni di record tra nodi ed archi).
\end{itemize}

\subsection{Conclusioni}
Nella parte finale del progetto di stage mi sono posto le seguenti domande per cercare di effettuare una presentazione esaustiva, in azienda, dell'analisi effettuata.\\
\\
\textbf{Vale la pena adottare la base di dati a grafo in azienda?}\\
\textit{Secondo la mia analisi si, però solamente per alcuni casi d'uso.}\\
Adottare un \textit{database} a grafo, e modellare i dati di conseguenza, per determinati casi d'uso renderebbero possibili determinate ricerche che prima potevano risultare troppo dispendiose o, addirittura, impossibili.\\
La perculiarità dei \textit{database} a grafo è la possibilità di attraversare, a costo costante, le varie entità ricostruendo le azioni compiute da una particolare entità indipendentemente dalla grandezza della base di dati. Questo aprirebbe, per l'azienda, nuove possibili ricerche come la costruzione dell'albero delle transazioni, dato un utente, per estrapolare determinate informazioni.\\
\\
\textbf{Risolve il problema iniziale del calcolo della reputazione descritto nella \hyperlink{sec:prob}{sezione 2.1.1}?}\\
\textit{Si, almeno utilizzando la base di dati generata casualmente.}\\
Ho eseguito le operazioni in basi di dati con varie unità di grandezze, fino ad arrivare a 30 milioni di transazioni, e il tempo necessario per calcolare la reputazione si aggirava tra i 2 millisecondi per quella totale e i 15 millisecondi per quella relativa. Questo grazie alla possibilità di eseguire queste determinate operazioni senza caricare tutto il \textit{database} in memoria.\\
\\
\textbf{Quale tecnologia utilizzare tra Neo4j e OrientDB?}\\
\textit{Secondo la mia analisi Neo4j.}\\
Ho preso questa decisione analizzandoli nei seguenti 3 ambiti, in ordine di importanza:
\begin{itemize}
\item{\textbf{Espressività:}} il linguaggio di interrogazione di Neo4j è nettamente migliore in termini di espressività. SQL è chiaramente un linguaggio non adatto per le ricerche nei grafi. Al contrario, quello di Neo4j, è sempre espressivo sia in termini di lettura di una \textit{query} sia nel crearla. Questo rende meno costoso, in termini di studio, il cambio tecnologico in azienda. 
\item{\textbf{Supporto alle tecnologie usate in azienda:}} il passaggio a Neo4j risulterebbe meno costoso , in termini di studio individuale, grazie al supporto nativo verso Spring Data. Il supporto di OrientDB verso questa tecnologia risulta ancora acerba.

\item{\textbf{Velocità:}} in termini di velocità di esecuzione di una \textit{query} Neo4j risulta più veloce, sopratutto all'aumentare delle transazioni sui nodi.
\end{itemize}















